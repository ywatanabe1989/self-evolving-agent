;;; -*- lexical-binding: t -*-
;;; Author: 2024-12-04 02:21:16
;;; Time-stamp: <2024-12-04 03:10:04 (ywatanabe)>
;;; File: ./self-evolving-agent/src/_sea-run.el

(require 'sea-config)
(require 'sea-utils)
(require 'sea-version-control)

;; (defun sea-run (input &optional retry-count)
;;   "Main entry point for agent thinking process.
;; INPUT is the task description or command for the agent.
;; RETRY-COUNT tracks number of retries on error."
;;   (interactive "sTask: ")
;;   (let ((retry-count (or retry-count 0)))
;;     (sea--validate-server-connection)
;;     (condition-case err
;;         (let* ((context (sea--get-context))
;;                (_ (message "SEA-RUN: Context retrieved: %S" context))
;;                (prompt (sea--build-prompt input context))
;;                (_ (message "SEA-RUN: Prompt built: %s" prompt))
;;                (response (sea--run-llm prompt)))
;;           (message "SEA-RUN: LLM Response received: %s" response)
;;           (when response
;;             (sea--append-history input response)
;;             (message "SEA-RUN: History appended")
;;             (sea--execute-response response)))
;;       (error
;;        (message "SEA-RUN: Error caught: %S" err)
;;        (if (< retry-count sea-max-retries)
;;            (sea-run "Something is wrong. Retry please" (1+ retry-count))
;;          (message "Max retries reached. Error: %S" err))))))

(defun sea--append-history (input response &optional error-msg)
  "Append INPUT and RESPONSE to history log file to create long context."
  (interactive)
  ;; (message "APPEND-HISTORY: Starting with input length: %d, response length: %d"
  ;;          (length input) (length response))
  (when (and input response)
    (let ((content (format "[%s]\nInput: %s\nResponse: %s%s\n\n"
                          (format-time-string "%Y-%m-%d %H:%M:%S")
                          (string-trim input)
                          (string-trim response)
                          (if error-msg (format "\nError: %s" error-msg) ""))))
      ;; (message "APPEND-HISTORY: Writing to %s" sea-history-file)
      (append-to-file content nil sea-history-file)
      ;; (message "APPEND-HISTORY: Completed")
      )))
;; (sea--append-history)

(defun sea--extract-elisp-code (text)
  "Extract elisp code from TEXT."
  (or (when (string-match "```elisp\\(\\(?:.\\|\n\\)*?\\)```" text)
        (string-trim (match-string 1 text)))
      (when (string-match "^(.*)" text)
        text)
      text))
;; (sea--extract-elisp-code "```elisp\nhello\\\```")


;; use (sea--execute-elip-commands commands), plesea
;; (defun sea--execute-response (response)
;;   "Execute the elisp code in RESPONSE."
;;   (message "SEA-EXECUTE: Evaluating response: %s" response)
;;   (let ((code (sea--extract-elisp-code response)))
;;     (when code
;;       (message "SEA-EXECUTE: Extracted code: %s" code)
;;       (let* ((socket-arg (format "--socket-name=%s" sea-server-socket-file))
;;              (wrapped-code (format "(progn (let ((buf (get-buffer-create \"*sea-output*\"))) (with-current-buffer buf (goto-char (point-max)) %s)))" code))
;;              (process (start-process "sea-exec" nil "emacsclient"
;;                                    socket-arg "-n" "-e" wrapped-code)))
;;         (set-process-sentinel
;;          process
;;          (lambda (proc event)
;;            (when (string-match "finished" event)
;;              (message "SEA command completed"))))))))



(defun sea--get-context ()
  "Gather current context including buffer state and history."
  (interactive)
  (setq sea-context
        `((history . ,(sea--read-history)))))
;; (sea--get-context)

(defun sea--build-prompt (input context)
  "Build prompt from INPUT and CONTEXT."
  (format "\nContext: %s\nTask: %s\nRespond with only elisp code without explanation or markdown:"
          (prin1-to-string context)
          input))

;; (defun sea--run-llm (prompt)
;;   "Send PROMPT to LLM and get response."
;;   (sea--log-message (format "LLM Input:\n%s" prompt))
;;   (let* ((request-backend 'url-retrieve)
;;          (url "https://api.anthropic.com/v1/messages")
;;          (headers `(("content-type" . "application/json")
;;                    ("x-api-key" . ,sea-anthropic-key)
;;                    ("anthropic-version" . "2023-06-01")))
;;          (data (json-encode
;;                 `((model . "claude-3-5-sonnet-20241022")
;;                   (max_tokens . 8192)
;;                   (messages . [((role . "user")
;;                               (content . ,prompt))]))))
;;          (response (request
;;                     url
;;                     :type "POST"
;;                     :headers headers
;;                     :data data
;;                     :parser 'json-read
;;                     :sync t)))
;;     (condition-case err
;;         (let* ((resp-data (request-response-data response))
;;                (content (alist-get 'content resp-data))
;;                (first-content (aref content 0))
;;                (result (alist-get 'text first-content)))
;;           (when result
;;             (sea--log-message (format "LLM Output:\n%s" result))
;;             result))
;;       (error (sea--log-message
;;               (format "Error in LLM request: %S\nResponse: %S" err response))
;;              nil))))

(defun sea--run-llm (prompt)
  "Send PROMPT to LLM and get response."
  (sea--log-message (format "LLM Input:\n%s" prompt))
  (let* ((request-backend 'url-retrieve)
         (url "https://api.anthropic.com/v1/messages")
         (headers `(("content-type" . "application/json")
                   ("x-api-key" . ,sea-anthropic-key)
                   ("anthropic-version" . "2023-06-01")))
         (system-message "You are a self-evolving agent (SEA) run on Emacs. Convert natural language tasks into executable Emacs Lisp commands. Output ONLY valid JSON in the format: {\"commands\": [{\"function\": \"command-name\", \"args\": [\"arg1\", \"arg2\"]}]}. No explanations or comments.")
         (data (json-encode
                `((model . "claude-3-5-sonnet-20241022")
                  (max_tokens . 8192)
                  (system . ,system-message)
                  (messages . [((role . "user")
                              (content . ,prompt))]))))
         (response (request
                    url
                    :type "POST"
                    :headers headers
                    :data data
                    :parser 'json-read
                    :sync t)))
    (condition-case err
        (let* ((resp-data (request-response-data response))
               (content (alist-get 'content resp-data))
               (first-content (aref content 0))
               (json-response (alist-get 'text first-content))
               (commands (json-read-from-string json-response)))
          (when commands
            (sea--log-message (format "LLM Output:\n%s" json-response))
            (sea--commands-to-elisp commands)))
      (error (sea--log-message
              (format "Error in LLM request: %S\nResponse: %S" err response))
             nil))))

(defun sea--commands-to-elisp (commands)
  "Convert JSON commands to Elisp code string."
  (let ((cmd-list (alist-get 'commands commands)))
    (mapconcat
     (lambda (cmd)
       (format "(%s %s)"
               (alist-get 'function cmd)
               (mapconcat
                (lambda (arg) (format "%S" arg))
                (alist-get 'args cmd)
                " ")))
     cmd-list
     "\n")))



(provide 'sea-run)

(message "%s was loaded." (file-name-nondirectory (or load-file-name buffer-file-name)))
