;;; -*- lexical-binding: t -*-
;;; Author: 2024-12-04 00:49:07
;;; Time-stamp: <2024-12-04 02:35:59 (ywatanabe)>
;;; File: ./self-evolving-agent/src/sea-run.el


;; USERINPUT: instruction written in natural language
;; LLM RESPONSE: response
;; Elisp command: commands extracted from LLM
;; LOGFILE: includes userinput, llm response, elisp commands, and error to loop through llm processing

(require 'sea-config)
(require 'sea-utils)
(require 'sea-version-control)

(defvar sea-context nil
  "Current context of the agent.")

(defvar sea-max-retries 1
  "Maximum number of retries for failed execution.")

;; (defun sea-run (input &optional retry-count)
;;   "Main entry point for agent thinking process.
;; INPUT is the task description or command for the agent.
;; RETRY-COUNT tracks number of retries on error."
;;   (interactive "sTask: ")
;;   (let ((retry-count (or retry-count 0)))
;;     (sea--validate-server-connection)
;;     (condition-case err
;;         (let* ((context (sea--get-context))
;;                (_ (message "SEA-RUN: Context retrieved: %S" context))
;;                (prompt (sea--build-prompt input context))
;;                (_ (message "SEA-RUN: Prompt built: %s" prompt))
;;                (response (sea--run-llm prompt)))
;;           (message "SEA-RUN: LLM Response received: %s" response)
;;           (when response
;;             (sea--append-history input response)
;;             (message "SEA-RUN: History appended")
;;             (sea--execute-response response)))
;;       (error
;;        (message "SEA-RUN: Error caught: %S" err)
;;        (if (< retry-count sea-max-retries)
;;            (sea-run "Something is wrong. Retry please" (1+ retry-count))
;;          (message "Max retries reached. Error: %S" err))))))

(defun sea--validate-server-connection ()
  "Validate essential environment settings."
  (message "DEBUG: Validating environment...")
  (unless (file-exists-p sea-server-socket-file)
    (message "DEBUG: Server socket not found, starting server...")
    (sea-init-or-connect))
  (message "DEBUG: Environment validation complete"))

(defun sea--append-history (input response &optional error-msg)
  "Append INPUT and RESPONSE to history log file to create long context."
  (message "APPEND-HISTORY: Starting with input length: %d, response length: %d"
           (length input) (length response))
  (when (and input response)
    (let ((content (format "[%s]\nInput: %s\nResponse: %s%s\n\n"
                          (format-time-string "%Y-%m-%d %H:%M:%S")
                          (string-trim input)
                          (string-trim response)
                          (if error-msg (format "\nError: %s" error-msg) ""))))
      (message "APPEND-HISTORY: Writing to %s" sea-history-file)
      (append-to-file content nil sea-history-file)
      (message "APPEND-HISTORY: Completed"))))


(defun sea--extract-code (text)
  "Extract elisp code from TEXT."
  (or (when (string-match "```elisp\\(\\(?:.\\|\n\\)*?\\)```" text)
        (string-trim (match-string 1 text)))
      (when (string-match "^(.*)" text)
        text)
      text))

(defun sea--execute-response (response)
  "Execute the elisp code in RESPONSE."
  (message "SEA-EXECUTE: Evaluating response: %s" response)
  (let ((code (sea--extract-code response)))
    (when code
      (message "SEA-EXECUTE: Extracted code: %s" code)
      (let* ((socket-arg (format "--socket-name=%s" sea-server-socket-file))
             (wrapped-code (format "(progn (let ((buf (get-buffer-create \"*sea-output*\"))) (with-current-buffer buf (goto-char (point-max)) %s)))" code))
             (process (start-process "sea-exec" nil "emacsclient"
                                   socket-arg "-n" "-e" wrapped-code)))
        (set-process-sentinel
         process
         (lambda (proc event)
           (when (string-match "finished" event)
             (message "SEA command completed"))))))))


(defun sea--get-context ()
  "Gather current context including buffer state and history."
  (setq sea-context
        `((history . ,(sea--read-history)))))

(defun sea--build-prompt (input context)
  "Build prompt from INPUT and CONTEXT."
  (format "\nContext: %s\nTask: %s\nRespond with only elisp code without explanation or markdown:"
          (prin1-to-string context)
          input))

;; (defun sea--run-llm (prompt)
;;   "Send PROMPT to LLM and get response."
;;   (sea--log-message (format "LLM Input:\n%s" prompt))
;;   (let* ((request-backend 'url-retrieve)
;;          (url "https://api.anthropic.com/v1/messages")
;;          (headers `(("content-type" . "application/json")
;;                    ("x-api-key" . ,sea-anthropic-key)
;;                    ("anthropic-version" . "2023-06-01")))
;;          (data (json-encode
;;                 `((model . "claude-3-5-sonnet-20241022")
;;                   (max_tokens . 8192)
;;                   (messages . [((role . "user")
;;                               (content . ,prompt))]))))
;;          (response (request
;;                     url
;;                     :type "POST"
;;                     :headers headers
;;                     :data data
;;                     :parser 'json-read
;;                     :sync t)))
;;     (condition-case err
;;         (let* ((resp-data (request-response-data response))
;;                (content (alist-get 'content resp-data))
;;                (first-content (aref content 0))
;;                (result (alist-get 'text first-content)))
;;           (when result
;;             (sea--log-message (format "LLM Output:\n%s" result))
;;             result))
;;       (error (sea--log-message
;;               (format "Error in LLM request: %S\nResponse: %S" err response))
;;              nil))))



(defun sea--run-llm (prompt)
  "Send PROMPT to LLM and get response."
  (sea--log-message (format "LLM Input:\n%s" prompt))
  (let* ((request-backend 'url-retrieve)
         (url "https://api.anthropic.com/v1/messages")
         (headers `(("content-type" . "application/json")
                   ("x-api-key" . ,sea-anthropic-key)
                   ("anthropic-version" . "2023-06-01")))
         (system-message "You are a self-evolving agent (SEA) run on Emacs. Convert natural language tasks into executable Emacs Lisp commands. Output ONLY valid JSON in the format: {\"commands\": [{\"function\": \"command-name\", \"args\": [\"arg1\", \"arg2\"]}]}. No explanations or comments.")
         (data (json-encode
                `((model . "claude-3-5-sonnet-20241022")
                  (max_tokens . 8192)
                  (system . ,system-message)
                  (messages . [((role . "user")
                              (content . ,prompt))]))))
         (response (request
                    url
                    :type "POST"
                    :headers headers
                    :data data
                    :parser 'json-read
                    :sync t)))
    (condition-case err
        (let* ((resp-data (request-response-data response))
               (content (alist-get 'content resp-data))
               (first-content (aref content 0))
               (json-response (alist-get 'text first-content))
               (commands (json-read-from-string json-response)))
          (when commands
            (sea--log-message (format "LLM Output:\n%s" json-response))
            (sea--commands-to-elisp commands)))
      (error (sea--log-message
              (format "Error in LLM request: %S\nResponse: %S" err response))
             nil))))

(defun sea--commands-to-elisp (commands)
  "Convert JSON commands to Elisp code string."
  (let ((cmd-list (alist-get 'commands commands)))
    (mapconcat
     (lambda (cmd)
       (format "(%s %s)"
               (alist-get 'function cmd)
               (mapconcat
                (lambda (arg) (format "%S" arg))
                (alist-get 'args cmd)
                " ")))
     cmd-list
     "\n")))



(provide 'sea-run)

;; I would like to run elisp commands as requested on the sea-launched emacs session
;; (sea-run "create a new buffer called helloworld and say hi")



;; APPEND-HISTORY: Starting with input length: 48, response length: 587
;; APPEND-HISTORY: Writing to /home/ywatanabe/.sea/logs/history.log
;; Added to /home/ywatanabe/.sea/logs/history.log
;; APPEND-HISTORY: Completed
;; SEA-RUN: History appended
;; SEA-EXECUTE: Evaluating response: Based on the task, I'll create a new buffer called "*launched*" and insert "hi". Here's the Elisp command:

;; ```elisp
;; (let ((new-buffer (get-buffer-create "*launched*")))  ; Create new buffer named "*launched*"
;;   (with-current-buffer new-buffer                     ; Switch to the new buffer context
;;     (insert "hi")                                     ; Insert "hi"
;;     (switch-to-buffer new-buffer)))                   ; Display the buffer
;; ```

;; This command sequence will:
;; 1. Create a new buffer specifically named "*launched*"
;; 2. Insert the text "hi" into it
;; 3. Display the new buffer
;; SEA-EXECUTE: Extracted code: (let ((new-buffer (get-buffer-create "*launched*")))  ; Create new buffer named "*launched*"
;;   (with-current-buffer new-buffer                     ; Switch to the new buffer context
;;     (insert "hi")                                     ; Insert "hi"
;;     (switch-to-buffer new-buffer)))                   ; Display the buffer
;; (closure (t) (proc event) (if (string-match "finished" event) (progn (message "SEA command completed"))))

(message "%s was loaded." (file-name-nondirectory (or load-file-name buffer-file-name)))
